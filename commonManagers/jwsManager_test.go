package commonManagers

import (
	"crypto/ed25519"
	"crypto/sha512"
	"encoding/json"
	"fmt"
	"github.com/stretchr/testify/require"
	bls12381 "github.com/kilic/bls12-381"

	"github.com/hyperledger/aries-framework-go/pkg/doc/signature/jsonld"
	// "github.com/hyperledger/aries-framework-go/pkg/doc/jose"
	// "github.com/hyperledger/aries-framework-go/pkg/doc/util"
	"github.com/hyperledger/aries-framework-go/pkg/doc/signature/proof"
	// "github.com/hyperledger/aries-framework-go/pkg/doc/signature/signer"
	"github.com/hyperledger/aries-framework-go/pkg/doc/signature/suite"
	"github.com/hyperledger/aries-framework-go/pkg/doc/signature/suite/ed25519signature2018"
	// "github.com/hyperledger/aries-framework-go/pkg/doc/signature/suite/jsonwebsignature2020"
	// sigverifier "github.com/hyperledger/aries-framework-go/pkg/doc/signature/verifier"
	"github.com/hyperledger/aries-framework-go/pkg/doc/util"
	"github.com/hyperledger/aries-framework-go/pkg/doc/util/signature"
	// "github.com/hyperledger/aries-framework-go/pkg/doc/verifiable"
	// "github.com/hyperledger/aries-framework-go/pkg/kms"
	"testing"
	"time"
)

const (
	seedSize        = 32	// frCompressedSize
	generateKeySalt = "BBS-SIG-KEYGEN-SALT-"
)

// PublicKey defines BLS Public Key.
type PublicKey struct {
	PointG2 *bls12381.PointG2
}

// PrivateKey defines BLS Public Key.
type PrivateKey struct {
	FR *bls12381.Fr
}

// from Aries verifiable_test
//nolint:gochecknoglobals
var (
	// Private key generated by ed25519.GenerateKey(rand.Reader).
	issuerPrivKey = ed25519.PrivateKey{72, 67, 163, 188, 235, 199, 239, 146, 129, 52, 228, 34, 44, 106, 23, 144, 189, 57, 115, 171, 4, 217, 54, 121, 41, 155, 251, 83, 1, 240, 238, 65, 234, 100, 192, 93, 251, 181, 198, 73, 122, 220, 27, 48, 93, 73, 166, 33, 152, 140, 168, 36, 9, 205, 59, 161, 137, 7, 164, 9, 176, 252, 1, 171} //nolint:lll
	issuerPubKey  = ed25519.PublicKey{234, 100, 192, 93, 251, 181, 198, 73, 122, 220, 27, 48, 93, 73, 166, 33, 152, 140, 168, 36, 9, 205, 59, 161, 137, 7, 164, 9, 176, 252, 1, 171}                                                                                                                                                   //nolint:lll
	issued        = time.Date(2010, time.January, 1, 19, 23, 24, 0, time.UTC)
	expired       = time.Date(2020, time.January, 1, 19, 23, 24, 0, time.UTC)

	bbsPrivKeyB64 = "PcVroyzTlmnYIIq8In8QOZhpK72AdTjj3EitB9tSNrg"
	bbsPubKeyB64  = "l0Wtf3gy5f140G5vCoCJw2420hwk6Xw65/DX3ycv1W7/eMky8DyExw+o1s2bmq3sEIJatkiN8f5D4k0766x0UvfbupFX+vVkeqnlOvT6o2cag2osQdMFbBQqAybOM4Gm" //nolint:lll
)

func TestCreateEd25519SignKeys(t *testing.T) {
	// It generates public and private signing keys for Ed25519Signature2018
	signingKeys, err := CreateEd25519SignKeys()
	require.NoError(t, err)
	require.NotEmpty(t, signingKeys.Id)
	require.NotEmpty(t, signingKeys.PrivateKeyBytes)
	require.NotEmpty(t, signingKeys.PublicKeyBytes)
	require.NotEmpty(t, signingKeys.PrivateKeyBase58)
	require.NotEmpty(t, signingKeys.PublicKeyBase58)
	require.NotEmpty(t, signingKeys.PrivateKeyBase64)
	require.NotEmpty(t, signingKeys.PublicKeyBase64)

	// It creates the signer entity with the generated keys
	signerEntity := signature.GetEd25519Signer(signingKeys.PrivateKeyBytes, signingKeys.PublicKeyBytes)
	require.NotEmpty(t, signerEntity.PublicKey)	// hexadecimal
	println("signerEntity.PublicKey = ", signerEntity.PublicKey)
	// fmt.Printf("signerEntity.PublicKey %v \n", signerEntity.PublicKey)
}

/*
	Package ed25519signature2018 implements the Ed25519Signature2018 signature suite for the Linked Data Signatures [LD-SIGNATURES] specification.
	It uses the RDF Dataset Normalization Algorithm [RDF-DATASET-NORMALIZATION] to transform the input document into its canonical form.
	It uses SHA-256 [RFC6234] as the message digest algorithm and Ed25519 [ED25519] as the signature algorithm.
	https://godoc.org/github.com/hyperledger/aries-framework-go/pkg/doc/signature/suite/ed25519signature2018
*/

func TestCreateVerifyData(t *testing.T) {
	signer := signature.GetEd25519Signer([]byte(issuerPrivKey), []byte(issuerPubKey))
	signSuite := ed25519signature2018.New(suite.WithSigner(signer))
	/*
	ed25519signature2018.Suite.CompactProof()
	ed25519signature2018.Suite.GetCanonicalDocument()
	ed25519signature2018.Suite.GetDigest()
	ed25519signature2018.Suite.Sign()
	ed25519signature2018.Suite.Verify()
	ed25519signature2018.Suite.Accept()
	*/

	// It creates the detached JWT Header
	jwtHeader := proof.CreateDetachedJWTHeader(&proof.Proof{
		Type: ed25519signature2018.SignatureType,
	})
	fmt.Printf("jwtHeader string = %v \n", jwtHeader)

	// And checks it is well done
	jwtHeaderMap := GetJwtHeaderMap(jwtHeader)
	require.Equal(t, "EdDSA", jwtHeaderMap["alg"])
	require.Equal(t, false, jwtHeaderMap["b64"])
	require.Equal(t, []interface{}{"b64"}, jwtHeaderMap["crit"])

	// It creates the proof
	created, err := time.Parse(time.RFC3339, "2018-03-15T00:00:00Z")
	require.NoError(t, err)
	// idSplit := strings.Split(creator, "#") // creator will contain didID#keyID
	// if len(idSplit) != creatorParts { return nil, fmt.Errorf("wrong id %s to resolve", idSplit)}
	// keyHandler, err := keyManager.Get(idSplit[1])
	newProof := &proof.Proof{
		Type:    ed25519signature2018.SignatureType,	// same as jwtHeader.Type
		Created: util.NewTime(created),
		Creator: "didID#keyID",
	}

	// It gets a DID document to be signed
	var doc map[string]interface{}
	err = json.Unmarshal([]byte(`{"signing":"test"}`), &doc)
	require.NoError(t, err)

	// It puts the JWS in the Proof created
	newProof.SignatureRepresentation = proof.SignatureJWS
	newProof.JWS = jwtHeader + "." + "."	// there is no payload here (it is de-attached in JSON Web Signature or JWS)

	// creates a data to be used to create/verify a digital signature in the
	// form of JSON Web Signature (JWS) with detached content
	jws, err := proof.CreateVerifyData(signSuite, doc, newProof)
	require.NoError(t, err)
	require.NotEmpty(t, jws)
	fmt.Printf("jws %s \n", string(jws))
	fmt.Println(string(jws))
}

type mockSignatureSuite struct {
	compactProof bool
}

// GetCanonicalDocument will return normalized/canonical version of the document.
func (s *mockSignatureSuite) GetCanonicalDocument(doc map[string]interface{},
	opts ...jsonld.ProcessorOpts) ([]byte, error) {
	return jsonld.Default().GetCanonicalDocument(doc, opts...)
}

// GetDigest returns document digest.
func (s *mockSignatureSuite) GetDigest(doc []byte) []byte {
	digest := sha512.Sum512(doc)
	return digest[:]
}

func (s *mockSignatureSuite) CompactProof() bool {
	return s.compactProof
}

//nolint:lll
const validDoc = `{
  "@context": ["https://w3id.org/did/v1"],
  "id": "did:example:21tDAKCERh95uGgKbJNHYp",
  "publicKey": [
    {
      "id": "did:example:123456789abcdefghi#keys-1",
      "type": "Secp256k1VerificationKey2018",
      "controller": "did:example:123456789abcdefghi",
      "publicKeyBase58": "H3C2AVvLMv6gmMNam3uVAjZpfkcJCwDwnZn6z3wXmqPV"
    },
    {
      "id": "did:example:123456789abcdefghw#key2",
      "type": "RsaVerificationKey2018",
      "controller": "did:example:123456789abcdefghw",
      "publicKeyPem": "-----BEGIN PUBLIC KEY-----\nMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAryQICCl6NZ5gDKrnSztO\n3Hy8PEUcuyvg/ikC+VcIo2SFFSf18a3IMYldIugqqqZCs4/4uVW3sbdLs/6PfgdX\n7O9D22ZiFWHPYA2k2N744MNiCD1UE+tJyllUhSblK48bn+v1oZHCM0nYQ2NqUkvS\nj+hwUU3RiWl7x3D2s9wSdNt7XUtW05a/FXehsPSiJfKvHJJnGOX0BgTvkLnkAOTd\nOrUZ/wK69Dzu4IvrN4vs9Nes8vbwPa/ddZEzGR0cQMt0JBkhk9kU/qwqUseP1QRJ\n5I1jR4g8aYPL/ke9K35PxZWuDp3U0UPAZ3PjFAh+5T+fc7gzCs9dPzSHloruU+gl\nFQIDAQAB\n-----END PUBLIC KEY-----"
    }
  ],
  "created": "2002-10-10T17:00:00Z"
}`

// from https://json-ld.org/test-suite/reports/#test_a5ebfe589bd62d1029790695808f8ff9
const test1 = `{
  "@id": "http://greggkellogg.net/foaf#me",
  "http://xmlns.com/foaf/0.1/name": "Gregg Kellogg"
}`

const test1Result = `<http://greggkellogg.net/foaf#me> <http://xmlns.com/foaf/0.1/name> "Gregg Kellogg" .
`
// cached value from https://w3id.org/security/v2
const SecurityJSONLDSchema = `
{
  "@context": [{
    "@version": 1.1
  }, "https://w3id.org/security/v1", {
    "AesKeyWrappingKey2019": "sec:AesKeyWrappingKey2019",
    "DeleteKeyOperation": "sec:DeleteKeyOperation",
    "DeriveSecretOperation": "sec:DeriveSecretOperation",
    "Ed25519Signature2018": "sec:Ed25519Signature2018",
    "Ed25519VerificationKey2018": "sec:Ed25519VerificationKey2018",
    "EquihashProof2018": "sec:EquihashProof2018",
    "ExportKeyOperation": "sec:ExportKeyOperation",
    "GenerateKeyOperation": "sec:GenerateKeyOperation",
    "KmsOperation": "sec:KmsOperation",
    "RevokeKeyOperation": "sec:RevokeKeyOperation",
    "RsaSignature2018": "sec:RsaSignature2018",
    "RsaVerificationKey2018": "sec:RsaVerificationKey2018",
    "Sha256HmacKey2019": "sec:Sha256HmacKey2019",
    "SignOperation": "sec:SignOperation",
    "UnwrapKeyOperation": "sec:UnwrapKeyOperation",
    "VerifyOperation": "sec:VerifyOperation",
    "WrapKeyOperation": "sec:WrapKeyOperation",
    "X25519KeyAgreementKey2019": "sec:X25519KeyAgreementKey2019",

    "allowedAction": "sec:allowedAction",
    "assertionMethod": {"@id": "sec:assertionMethod", "@type": "@id", "@container": "@set"},
    "authentication": {"@id": "sec:authenticationMethod", "@type": "@id", "@container": "@set"},
    "capability": {"@id": "sec:capability", "@type": "@id"},
    "capabilityAction": "sec:capabilityAction",
    "capabilityChain": {"@id": "sec:capabilityChain", "@type": "@id", "@container": "@list"},
    "capabilityDelegation": {"@id": "sec:capabilityDelegationMethod", "@type": "@id", "@container": "@set"},
    "capabilityInvocation": {"@id": "sec:capabilityInvocationMethod", "@type": "@id", "@container": "@set"},
    "caveat": {"@id": "sec:caveat", "@type": "@id", "@container": "@set"},
    "challenge": "sec:challenge",
    "ciphertext": "sec:ciphertext",
    "controller": {"@id": "sec:controller", "@type": "@id"},
    "delegator": {"@id": "sec:delegator", "@type": "@id"},
    "equihashParameterK": {"@id": "sec:equihashParameterK", "@type": "xsd:integer"},
    "equihashParameterN": {"@id": "sec:equihashParameterN", "@type": "xsd:integer"},
    "invocationTarget": {"@id": "sec:invocationTarget", "@type": "@id"},
    "invoker": {"@id": "sec:invoker", "@type": "@id"},
    "jws": "sec:jws",
    "keyAgreement": {"@id": "sec:keyAgreementMethod", "@type": "@id", "@container": "@set"},
    "kmsModule": {"@id": "sec:kmsModule"},
    "parentCapability": {"@id": "sec:parentCapability", "@type": "@id"},
    "plaintext": "sec:plaintext",
    "proof": {"@id": "sec:proof", "@type": "@id", "@container": "@graph"},
    "proofPurpose": {"@id": "sec:proofPurpose", "@type": "@vocab"},
    "proofValue": "sec:proofValue",
    "referenceId": "sec:referenceId",
    "unwrappedKey": "sec:unwrappedKey",
    "verificationMethod": {"@id": "sec:verificationMethod", "@type": "@id"},
    "verifyData": "sec:verifyData",
    "wrappedKey": "sec:wrappedKey"
  }]
}
`
